import spawn from 'nano-spawn';
import fs from 'fs-extra';
import { fileURLToPath } from 'node:url';
import { dirname, join, resolve, sep } from 'node:path';
import { sep as posixSep } from 'node:path/posix';
import {
  type FunctionDeclarationStructure,
  type InterfaceDeclaration,
  type ModuleDeclaration,
  ModuleDeclarationKind,
  Project,
  StructureKind,
  SyntaxKind,
} from 'ts-morph';
import bcd, {
  type Identifier,
} from '@mdn/browser-compat-data' with { type: 'json' };

// Fetch latest version

console.log(
  'Getting latest version of \x1b[36m@types/chrome\x1b[0m, \x1b[36m@types/firefox-webext-browser\x1b[0m',
);
await spawn('pnpm', [
  'i',
  '--ignore-scripts',
  '-D',
  '@types/chrome@latest',
  '@types/firefox-webext-browser@latest',
]);

// Generate new package.json

console.log('Generating new \x1b[36mpackage.json\x1b[0m');

const pkgJsonPath = fileURLToPath(
  import.meta.resolve('@types/chrome/package.json'),
);
const firefoxPkgJsonPath = fileURLToPath(
  import.meta.resolve('@types/firefox-webext-browser/package.json'),
);
const pkgDir = dirname(pkgJsonPath);
const firefoxPkgDir = dirname(firefoxPkgJsonPath);
const pkgJson = await fs.readJson(pkgJsonPath);
const firefoxPkgJson = await fs.readJson(firefoxPkgJsonPath);
const pkgJsonTemplate = await fs.readFile('templates/package.json', 'utf8');
const newPkgJson = JSON.parse(
  pkgJsonTemplate
    .replaceAll('{{chromeTypesVersion}}', pkgJson.version)
    .replaceAll('{{firefoxTypesVersion}}', firefoxPkgJson.version),
);
newPkgJson.dependencies = pkgJson.dependencies;
newPkgJson.peerDependencies = pkgJson.peerDependencies;
newPkgJson.peerDependenciesMeta = pkgJson.peerDependenciesMeta;

const outPkgJsonPath = resolve('package.json');
await fs.writeJson(outPkgJsonPath, newPkgJson);
await spawn('pnpm', ['-w', 'prettier', '--write', outPkgJsonPath]);

// Generate declaration files

console.log('Generating declaration files');

const outDir = resolve('src/gen');

const project = new Project({
  compilerOptions: {
    declaration: true,
    types: ['@types/chrome', '@types/firefox-webext-browser'],
    baseUrl: outDir,
  },
});
const chromeFile = resolve(pkgDir, 'index.d.ts');
const firefoxFile = resolve(firefoxPkgDir, 'index.d.ts');
const chrome = project.addSourceFileAtPath(chromeFile);
const firefox = project.addSourceFileAtPath(firefoxFile);

const browserIndexFile = project.createSourceFile(
  join(outDir, 'index.d.ts'),
  `/* DO NOT EDIT - generated by scripts/generate.ts */
${chrome
  .getPathReferenceDirectives()
  .map((file) => `/// <reference path="${file.getText()}" />`)
  .join('\n')}
${chrome
  .getTypeReferenceDirectives()
  .map((file) => `/// <reference types="${file.getText()}" />`)
  .join('\n')}
  \n`,
  { overwrite: true },
);
const browserNamespace = browserIndexFile.addModule({
  name: 'Browser',
  isExported: true,
  kind: StructureKind.Module,
  declarationKind: ModuleDeclarationKind.Namespace,
});

const browserExtensionCompatData = bcd.webextensions;
const browserInterface = browserIndexFile.addInterface({
  name: '_Browser',
  isExported: true,
  kind: StructureKind.Interface,
});

const modules: Record<string, ModuleDeclaration> = {};
const allModules = (chrome.getModule('chrome')?.getModules() || []).concat(
  firefox?.getModules() || [],
);
allModules?.forEach((originalModule) => {
  const moduleName = originalModule
    .getName()
    .replace(/^(browser\.|chrome\.)/, '');
  if (modules[moduleName]) {
    const existingModule = modules[moduleName];
    existingModule.addInterfaces(
      originalModule
        .getInterfaces()
        .filter((i) => !existingModule.getInterface(i.getName()))
        .map((i) => i.getStructure()),
    );
    existingModule.addClasses(
      originalModule
        .getClasses()
        .filter((c) => !existingModule.getClass(c.getName() ?? 'NONE'))
        .map((c) => c.getStructure()),
    );
    existingModule.addFunctions(
      originalModule
        .getFunctions()
        .filter((f) => !existingModule.getFunction(f.getName() ?? 'NONE'))
        .map((f) => f.getStructure() as FunctionDeclarationStructure),
    );
    existingModule.addVariableStatements(
      originalModule
        .getVariableStatements()
        .filter(
          (v) =>
            !existingModule.getVariableStatement(
              v.getFirstChildByKind(SyntaxKind.Identifier)?.getText() ?? 'NONE',
            ),
        )
        .map((varDecl) => varDecl.getStructure()),
    );
  } else {
    const newModule = browserNamespace.addModule({
      ...originalModule.getStructure(),
      name: moduleName,
      isExported: true,
      kind: StructureKind.Module,
      declarationKind: ModuleDeclarationKind.Namespace,
    });
    modules[moduleName] = newModule;
  }

  const moduleCompatData = browserExtensionCompatData['api'][moduleName];
  if (moduleName.includes('.')) {
    const moduleCompatApiData = browserExtensionCompatData['api'];
    const [wrapperModuleName, innerModuleName] = moduleName.split('.');
    const nestedModuleCompatData =
      moduleCompatApiData[wrapperModuleName]?.[innerModuleName] ?? {};

    const compatData: Record<string, boolean> = Object.fromEntries(
      Object.entries(nestedModuleCompatData)
        .map(([name, data]) =>
          Object.hasOwn(data, '__compat')
            ? ([
                name,
                !Object.entries(
                  (data as Identifier).__compat?.support ?? {},
                ).some(([, support]) =>
                  Array.isArray(support)
                    ? support[0].version_added === false
                    : support.version_added === false,
                ),
              ] as const)
            : [name, undefined],
        )
        .filter(Boolean),
    );
    const temporaryInterface = browserIndexFile.addInterface({
      name: '_' + moduleName.replace(/\./g, '_'),
      isExported: true,
    });

    addFunction(originalModule, temporaryInterface, {
      compatData,
      name: innerModuleName,
    });
    addVariable(originalModule, temporaryInterface, {
      compatData,
      name: innerModuleName,
    });
    const temporaryInterfaceText = temporaryInterface.getText();
    const originalProperty = browserInterface.getProperty(wrapperModuleName);
    if (originalProperty) {
      const originalInterface = originalProperty.getTypeNodeOrThrow().getText();
      const newPropertyText = temporaryInterfaceText.slice(
        temporaryInterfaceText.indexOf('{') + 1,
        temporaryInterfaceText.lastIndexOf('}'),
      );
      if (originalInterface.includes('}')) {
        originalProperty.set({
          type: `${originalInterface.slice(0, originalInterface.lastIndexOf('}'))} ${newPropertyText}}`,
        });
      } else {
        originalProperty.set({
          type: `${originalInterface} & {${newPropertyText}}`,
        });
      }
    } else {
      const newPropertyText = temporaryInterfaceText.slice(
        temporaryInterfaceText.indexOf('{') + 1,
        temporaryInterfaceText.lastIndexOf('}'),
      );

      browserInterface.addProperty({
        name: wrapperModuleName,
        type: `{\n${newPropertyText}\n}`,
      });
    }

    temporaryInterface.remove();
    return;
  }
  if (!moduleCompatData) {
    browserInterface.addProperty({
      name: moduleName,
      type: 'typeof Browser.' + moduleName,
      hasQuestionToken: !moduleCompatData,
    });
  } else {
    const compatData: Record<string, boolean> = Object.fromEntries(
      Object.entries(moduleCompatData)
        .map(([name, data]) =>
          Object.hasOwn(data, '__compat')
            ? ([
                name,
                !Object.entries(
                  (data as Identifier).__compat?.support ?? {},
                ).some(([, support]) =>
                  Array.isArray(support)
                    ? support[0].version_added === false
                    : support.version_added === false,
                ),
              ] as const)
            : [name, undefined],
        )
        .filter(Boolean),
    );
    addFunction(originalModule, browserInterface, {
      compatData,
      name: moduleName,
    });
    addVariable(originalModule, browserInterface, {
      compatData,
      name: moduleName,
    });
  }
});

browserInterface.formatText();
await browserIndexFile.save();

// move Chrome declaration files to src/gen
const declarationFileMapping = (
  await fs.readdir(pkgDir, {
    recursive: true,
    encoding: 'utf8',
  })
)
  // Filter to .d.ts files
  .filter((file) => file.endsWith('.d.ts') && !file.startsWith('index.'))
  // Map to usable paths
  .map((file) => ({
    file: file.replaceAll(sep, posixSep),
    srcPath: join(pkgDir, file),
    destPath: join(outDir, file),
  }));

for (const { file, srcPath, destPath } of declarationFileMapping) {
  const content = await fs.readFile(srcPath, 'utf8');
  const destDir = dirname(destPath);
  await fs.mkdir(destDir, { recursive: true });
  await fs.writeFile(destPath, content);
  console.log(`  \x1b[2m-\x1b[0m \x1b[36m${file}\x1b[0m`);
}

await fs.writeJson(outPkgJsonPath, newPkgJson);

await spawn('pnpm', [
  '-w',
  'prettier',
  '--write',
  browserIndexFile.getFilePath(),
]);

// Done!

console.log(
  '\x1b[32mâœ”\x1b[0m Done in ' + performance.now().toFixed(0) + ' ms',
);

// Transformations

function addFunction(
  fromModule: ModuleDeclaration,
  toInterface: InterfaceDeclaration,
  options: {
    name: string;
    compatData: Record<string, boolean>;
  },
) {
  const moduleName = fromModule.getName().replace(/^(browser\.|chrome\.)/, '');
  const propertyEntries = fromModule.getFunctions().map((fn) => {
    const fnName = fn.getNameOrThrow();
    return [fnName, options.compatData[fnName] === false];
  });
  const propertyText = Object.entries(Object.fromEntries(propertyEntries))
    .map(([name, optional]) => {
      return `${name}${optional ? '?' : ''}: typeof Browser.${moduleName}.${name};`;
    })
    .join('\n');
  const existingProperty = toInterface.getProperty(options.name);
  if (propertyText.trim() === '') {
    return;
  }
  if (existingProperty) {
    const originalInterface = existingProperty.getText();
    const originalPropertyText = originalInterface.slice(
      originalInterface.indexOf('{') + 1,
      originalInterface.lastIndexOf('}'),
    );

    const propertyText = Object.entries(Object.fromEntries(propertyEntries))
      .filter(([name]) => !originalPropertyText.includes(name))
      .map(([name, optional]) => {
        return `${name}${optional ? '?' : ''}: typeof Browser.${moduleName}.${name};`;
      })
      .join('\n');
    existingProperty.set({
      type: `{\n${propertyText}${originalPropertyText.replace('  ', '')}\n}`,
    });
  } else {
    toInterface.addProperty({
      name: options.name,
      type: `{\n${propertyText}\n}`,
    });
  }
}
function addVariable(
  fromModule: ModuleDeclaration,
  toInterface: InterfaceDeclaration,
  options: {
    compatData: Record<string, boolean>;
    name: string;
  },
) {
  const moduleName = fromModule.getName().replace(/^(browser\.|chrome\.)/, '');
  const propertyEntries = fromModule.getVariableDeclarations().map((fn) => {
    const fnName = fn
      .getFirstChildByKindOrThrow(SyntaxKind.Identifier)
      .getText();
    return [fnName, options.compatData[fnName] === false];
  });

  const existingProperty = toInterface.getProperty(options.name);

  if (existingProperty) {
    const originalInterface = existingProperty.getText();
    const originalPropertyText = originalInterface.slice(
      originalInterface.indexOf('{') + 1,
      originalInterface.lastIndexOf('}'),
    );

    const propertyText = Object.entries(Object.fromEntries(propertyEntries))
      .filter(([name]) => !originalPropertyText.includes(name))
      .map(([name, optional]) => {
        return `${name}${optional ? '?' : ''}: typeof Browser.${moduleName}.${name};`;
      })
      .join('\n');
    existingProperty.set({
      type: `{\n${propertyText}${originalPropertyText.replace('  ', '')}\n}`,
    });
  } else {
    const propertyText = Object.entries(Object.fromEntries(propertyEntries))
      .map(([name, optional]) => {
        return `${name}${optional ? '?' : ''}: typeof Browser.${moduleName}.${name};`;
      })
      .join('\n');
    if (propertyText.trim() === '') {
      return;
    }
    toInterface.addProperty({
      name: options.name,
      type: `{\n${propertyText}\n}`,
    });
  }
}
